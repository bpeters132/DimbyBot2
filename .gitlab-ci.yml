# Define stages
stages:
  - build
  - deploy

variables:
  # Use Docker-in-Docker driver
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # Define image names using GitLab pre-defined variables
  # $CI_REGISTRY_IMAGE is typically <registry>/<user>/<project>
  BOT_IMAGE: $CI_REGISTRY_IMAGE/bot:$CI_COMMIT_SHORT_SHA
  LAVALINK_IMAGE: $CI_REGISTRY_IMAGE/lavalink:$CI_COMMIT_SHORT_SHA
  BOT_IMAGE_LATEST: $CI_REGISTRY_IMAGE/bot:latest
  LAVALINK_IMAGE_LATEST: $CI_REGISTRY_IMAGE/lavalink:latest

# Use Docker-in-Docker service
services:
  - docker:dind

build_images:
  stage: build
  image: docker:latest # Use the official Docker image
  script:
    # Login required for pushing
    - echo "Logging in to GitLab Container Registry..."
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    # Build images using Dockerfiles
    - echo "Building Bot image..."
    - docker build -t $BOT_IMAGE -t $BOT_IMAGE_LATEST -f Dockerfile .
    - echo "Building Lavalink image..."
    - docker build -t $LAVALINK_IMAGE -t $LAVALINK_IMAGE_LATEST -f Lavalink/Dockerfile ./Lavalink

    # Push images to GitLab Container Registry
    - echo "Pushing images to registry..."
    - docker push $BOT_IMAGE
    - docker push $BOT_IMAGE_LATEST
    - docker push $LAVALINK_IMAGE
    - docker push $LAVALINK_IMAGE_LATEST
  # Only run on master branch
  only:
    - master

deploy_stack:
  stage: deploy
  # Use Debian image for potentially better SSH key handling
  image: debian:stable-slim 
  variables:
    DEPLOY_SERVER_SSH_PORT: 22
  before_script:
    # Install SSH client (includes scp) and sed
    - apt-get update && apt-get install -y --no-install-recommends openssh-client sed
    # Create SSH directory
    - mkdir -p ~/.ssh
    # Copy SSH key CONTENT from the FILE PATH specified by the variable to our standard location
    - cp "$SSH_PRIVATE_KEY" ~/.ssh/id_rsa_tmp # Assumes $SSH_PRIVATE_KEY is File variable path
    # Ensure correct permissions for the key file
    - chmod 600 ~/.ssh/id_rsa_tmp
    # Add server host key to known hosts
    - SERVER_HOST=$(echo $DEPLOY_SERVER | cut -d '@' -f 2)
    - ssh-keyscan -p $DEPLOY_SERVER_SSH_PORT $SERVER_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - echo "Generating .env file for deployment..."
    - |
      cat << EOF > ci_generated.env
      # Generated by GitLab CI
      BOT_TOKEN="$BOT_TOKEN"
      CLIENT_ID="$CLIENT_ID"
      GUILD_ID="$GUILD_ID"
      OWNER_ID="$OWNER_ID"
      DEV_MODE="$DEV_MODE"
      LAVALINK_HOST="$LAVALINK_HOST"
      LAVALINK_PORT="$LAVALINK_PORT"
      LAVALINK_PASSWORD="$LAVALINK_PASSWORD"
      LAVALINK_NODE_ID="$LAVALINK_NODE_ID"
      LAVALINK_SECURE="$LAVALINK_SECURE"
      LAVALINK_YOUTUBE_POT_TOKEN="$LAVALINK_YOUTUBE_POT_TOKEN"
      LAVALINK_YOUTUBE_POT_VISITORDATA="$LAVALINK_YOUTUBE_POT_VISITORDATA"
      LAVALINK_SPOTIFY_ENABLED="$LAVALINK_SPOTIFY_ENABLED"
      LAVALINK_SPOTIFY_CLIENT_ID="$LAVALINK_SPOTIFY_CLIENT_ID"
      LAVALINK_SPOTIFY_CLIENT_SECRET="$LAVALINK_SPOTIFY_CLIENT_SECRET"
      LAVALINK_SPOTIFY_COUNTRY_CODE="$LAVALINK_SPOTIFY_COUNTRY_CODE"
      LAVALINK_SPOTIFY_PLAYLIST_LOAD_LIMIT="$LAVALINK_SPOTIFY_PLAYLIST_LOAD_LIMIT"
      LAVALINK_SPOTIFY_ALBUM_LOAD_LIMIT="$LAVALINK_SPOTIFY_ALBUM_LOAD_LIMIT"
      EMAIL_USER="$EMAIL_USER"
      EMAIL_PASS="$EMAIL_PASS"
      GITLAB_EMAIL="$GITLAB_EMAIL"
      # Add image tags needed by compose
      BOT_IMAGE=$BOT_IMAGE_LATEST
      LAVALINK_IMAGE=$LAVALINK_IMAGE_LATEST
      EOF
    - echo "Copying .env file to server $DEPLOY_SERVER..."
    - scp -i ~/.ssh/id_rsa_tmp -P $DEPLOY_SERVER_SSH_PORT -o StrictHostKeyChecking=accept-new ci_generated.env $DEPLOY_SERVER:/home/bot/.env

    # ADD THIS STEP: Copy docker-compose.yml to the server
    - echo "Copying docker-compose.yml to server $DEPLOY_SERVER..."
    - scp -i ~/.ssh/id_rsa_tmp -P $DEPLOY_SERVER_SSH_PORT -o StrictHostKeyChecking=accept-new docker-compose.yml $DEPLOY_SERVER:/home/bot/docker-compose.yml

    - echo "Generating deployment script..."
    # Use 'EOS' to prevent local expansion of variables like $BOT_IMAGE inside the script definition
    - |
      cat << 'EOS' > ci_deploy.sh
      #!/bin/bash
      set -e # Exit immediately if a command exits with a non-zero status.

      echo "Changing to deployment directory..."
      cd /home/bot

      # Source the .env file to load image tags and potentially other config
      echo "Sourcing .env file..."
      if [ -f .env ]; then
        # Export variables from .env file for use in this script
        export $(grep -v '^#' .env | xargs)
      else
        echo "Error: .env file not found in /home/bot"
        exit 1
      fi

      # Note: Docker login is omitted here. Ensure the server has credentials
      # configured to pull from $CI_REGISTRY (e.g., via docker login run manually once,
      # credential helper, or adding credentials to the .env file - less recommended).

      echo "Updating docker-compose.yml image tags..."
      # Use variables sourced from .env. Assumes 'bot:'/'lavalink:' are unique identifiers.
      # Adjust the sed patterns if your image lines are structured differently.
      sed -i "s|image: .*bot.*|image: $BOT_IMAGE|" docker-compose.yml
      sed -i "s|image: .*lavalink.*|image: $LAVALINK_IMAGE|" docker-compose.yml

      echo "Restarting Docker Compose stack..."
      /usr/bin/docker compose down
      echo "Pulling latest images specified in compose file..."
      /usr/bin/docker compose pull # Pull new images explicitly based on updated compose file
      echo "Starting docker compose stack..."
      /usr/bin/docker compose up -d

      echo "Deployment script finished successfully."
      EOS
    - chmod +x ci_deploy.sh # Make the script executable before copying

    - echo "Copying deployment script to server $DEPLOY_SERVER..."
    - scp -i ~/.ssh/id_rsa_tmp -P $DEPLOY_SERVER_SSH_PORT -o StrictHostKeyChecking=accept-new ci_deploy.sh $DEPLOY_SERVER:/home/bot/ci_deploy.sh

    - echo "Executing deployment script on server $DEPLOY_SERVER..."
    # Execute the script using bash
    - ssh -i ~/.ssh/id_rsa_tmp -p $DEPLOY_SERVER_SSH_PORT -o StrictHostKeyChecking=accept-new $DEPLOY_SERVER "/bin/bash /home/bot/ci_deploy.sh"

  environment:
    name: Production # Define an environment name
    url: http://your.server.com # Optional: Add the URL of your deployment
    
  # Only run on master branch
  only:
    - master