# Define stages
stages:
  - build
  - deploy

variables:
  # Use Docker-in-Docker driver
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # Define image names using GitLab pre-defined variables
  # $CI_REGISTRY_IMAGE is typically <registry>/<user>/<project>
  BOT_IMAGE: $CI_REGISTRY_IMAGE/bot:$CI_COMMIT_SHORT_SHA
  LAVALINK_IMAGE: $CI_REGISTRY_IMAGE/lavalink:$CI_COMMIT_SHORT_SHA
  BOT_IMAGE_LATEST: $CI_REGISTRY_IMAGE/bot:latest
  LAVALINK_IMAGE_LATEST: $CI_REGISTRY_IMAGE/lavalink:latest

# Use Docker-in-Docker service
services:
  - docker:dind

build_images:
  stage: build
  image: docker:latest # Use the official Docker image
  script:
    # Build images using Dockerfiles (not compose build, for clearer tagging)
    - echo "Building Bot image..."
    - docker build -t $BOT_IMAGE -t $BOT_IMAGE_LATEST -f Dockerfile .
    - echo "Building Lavalink image..."
    - docker build -t $LAVALINK_IMAGE -t $LAVALINK_IMAGE_LATEST -f Lavalink/Dockerfile ./Lavalink

    # Push images to GitLab Container Registry
    - echo "Pushing images to registry..."
    - docker push $BOT_IMAGE
    - docker push $BOT_IMAGE_LATEST
    - docker push $LAVALINK_IMAGE
    - docker push $LAVALINK_IMAGE_LATEST
  
  # Only run on default branch (e.g., main) or tags
  only: 
    - main # Adjust if your default branch is different
    - tags

# Job definition must start at column 1
deploy_stack:
  # Keys under the job name must be indented (e.g., 2 spaces)
  stage: deploy
  image: debian:stable-slim
  variables:
    DEPLOY_SERVER_SSH_PORT: 22
  before_script:
    # Install SSH client and sed
    - apt-get update && apt-get install -y --no-install-recommends openssh-client sed
    # Create SSH directory
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh

    # -- Handling File Variable --
    - echo "Checking SSH_PRIVATE_KEY (should be a path for File type variable): \"$SSH_PRIVATE_KEY\""
    # Check if path exists and is a file
    - '[ ! -f "$SSH_PRIVATE_KEY" ] && { echo "ERROR: File variable path \"$SSH_PRIVATE_KEY\" does not exist or is not a file!"; echo "Ensure the variable type is set to 'File' in GitLab CI/CD settings."; exit 1; } || echo "File variable path \"$SSH_PRIVATE_KEY\" exists."'

    # Copy SSH key CONTENT from the FILE PATH specified by the variable to our standard location
    - echo "Copying key content from path $SSH_PRIVATE_KEY to ~/.ssh/id_rsa_tmp..."
    - cp "$SSH_PRIVATE_KEY" ~/.ssh/id_rsa_tmp

    # Ensure correct permissions for the key file
    - chmod 600 ~/.ssh/id_rsa_tmp

    # Add server host key to known hosts
    - SERVER_HOST=$(echo $DEPLOY_SERVER | cut -d '@' -f 2)
    # Check if variables are set before keyscan
    - '[ -z "$SERVER_HOST" ] || [ -z "$DEPLOY_SERVER_SSH_PORT" ] && echo "ERROR: DEPLOY_SERVER ($DEPLOY_SERVER) or DEPLOY_SERVER_SSH_PORT ($DEPLOY_SERVER_SSH_PORT) is empty or invalid for ssh-keyscan." && exit 1 || echo "Variables for keyscan seem okay."'
    - ssh-keyscan -p $DEPLOY_SERVER_SSH_PORT $SERVER_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - echo "Deploying to server $DEPLOY_SERVER on port $DEPLOY_SERVER_SSH_PORT using identity file..."
    # SSH into the server using the identity file directly
    - >
      ssh -i ~/.ssh/id_rsa_tmp -p $DEPLOY_SERVER_SSH_PORT -o StrictHostKeyChecking=accept-new $DEPLOY_SERVER 
      "cd /home/bot && \
      echo 'Logging into GitLab Registry on server...' && \
      docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY && \
      echo 'Pulling latest images...' && \
      export BOT_IMAGE=$BOT_IMAGE_LATEST && \
      export LAVALINK_IMAGE=$LAVALINK_IMAGE_LATEST && \
      
      # Export necessary secrets from GitLab CI/CD Variables
      export BOT_TOKEN='$BOT_TOKEN' && \
      export CLIENT_ID='$CLIENT_ID' && \
      export GUILD_ID='$GUILD_ID' && \
      export OWNER_ID='$OWNER_ID' && \
      export DEV_MODE='$DEV_MODE' && \
      export LAVALINK_HOST='$LAVALINK_HOST' && \
      export LAVALINK_PORT='$LAVALINK_PORT' && \
      export LAVALINK_PASSWORD='$LAVALINK_PASSWORD' && \
      export LAVALINK_NODE_ID='$LAVALINK_NODE_ID' && \
      export LAVALINK_SECURE='$LAVALINK_SECURE' && \
      export LAVALINK_YOUTUBE_POT_TOKEN='$LAVALINK_YOUTUBE_POT_TOKEN' && \
      export LAVALINK_YOUTUBE_POT_VISITORDATA='$LAVALINK_YOUTUBE_POT_VISITORDATA' && \
      export LAVALINK_SPOTIFY_ENABLED='$LAVALINK_SPOTIFY_ENABLED' && \
      export LAVALINK_SPOTIFY_CLIENT_ID='$LAVALINK_SPOTIFY_CLIENT_ID' && \
      export LAVALINK_SPOTIFY_CLIENT_SECRET='$LAVALINK_SPOTIFY_CLIENT_SECRET' && \
      export LAVALINK_SPOTIFY_COUNTRY_CODE='$LAVALINK_SPOTIFY_COUNTRY_CODE' && \
      export EMAIL_USER='$EMAIL_USER' && \
      export EMAIL_PASS='$EMAIL_PASS' && \
      export GITLAB_EMAIL='$GITLAB_EMAIL' && \
      
      # Update docker-compose.yml on the server to use the specific image tags
      echo 'Updating docker-compose.yml image tags...' && \
      sed -i \"s|image: .*bot.*|image: $BOT_IMAGE|\" docker-compose.yml && \
      sed -i \"s|image: .*lavalink.*|image: $LAVALINK_IMAGE|\" docker-compose.yml && \

      # Use docker compose V2 syntax (docker compose)
      echo 'Stopping existing containers (if any)..' && \
      docker compose down && \
      echo 'Starting new containers...' && \
      docker compose up -d"
      
  environment:
    name: Production 
    url: http://your.server.com 
    
  only:
    - master